export declare const IPSetIPAddressVersion: {
    readonly Ipv4: "IPV4";
    readonly Ipv6: "IPV6";
};
/**
 * Type of addresses in the IPSet, use IPV4 for IPV4 IP addresses, IPV6 for IPV6 address.
 */
export declare type IPSetIPAddressVersion = (typeof IPSetIPAddressVersion)[keyof typeof IPSetIPAddressVersion];
export declare const IPSetScope: {
    readonly Cloudfront: "CLOUDFRONT";
    readonly Regional: "REGIONAL";
};
/**
 * Use CLOUDFRONT for CloudFront IPSet, use REGIONAL for Application Load Balancer and API Gateway.
 */
export declare type IPSetScope = (typeof IPSetScope)[keyof typeof IPSetScope];
export declare const LoggingConfigurationConditionActionConditionPropertiesAction: {
    readonly Allow: "ALLOW";
    readonly Block: "BLOCK";
    readonly Count: "COUNT";
};
/**
 * Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
 */
export declare type LoggingConfigurationConditionActionConditionPropertiesAction = (typeof LoggingConfigurationConditionActionConditionPropertiesAction)[keyof typeof LoggingConfigurationConditionActionConditionPropertiesAction];
export declare const LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior: {
    readonly Match: "MATCH";
    readonly NoMatch: "NO_MATCH";
    readonly EvaluateAsString: "EVALUATE_AS_STRING";
};
/**
 * What AWS WAF should do if it fails to completely parse the JSON body.
 */
export declare type LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior = (typeof LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior)[keyof typeof LoggingConfigurationFieldToMatchJsonBodyPropertiesInvalidFallbackBehavior];
export declare const LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope: {
    readonly All: "ALL";
    readonly Key: "KEY";
    readonly Value: "VALUE";
};
/**
 * The parts of the JSON to match against using the MatchPattern. If you specify All, AWS WAF matches against keys and values.
 */
export declare type LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope = (typeof LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope)[keyof typeof LoggingConfigurationFieldToMatchJsonBodyPropertiesMatchScope];
export declare const LoggingConfigurationFilterBehavior: {
    readonly Keep: "KEEP";
    readonly Drop: "DROP";
};
/**
 * How to handle logs that satisfy the filter's conditions and requirement.
 */
export declare type LoggingConfigurationFilterBehavior = (typeof LoggingConfigurationFilterBehavior)[keyof typeof LoggingConfigurationFilterBehavior];
export declare const LoggingConfigurationFilterRequirement: {
    readonly MeetsAll: "MEETS_ALL";
    readonly MeetsAny: "MEETS_ANY";
};
/**
 * Logic to apply to the filtering conditions. You can specify that, in order to satisfy the filter, a log must match all conditions or must match at least one condition.
 */
export declare type LoggingConfigurationFilterRequirement = (typeof LoggingConfigurationFilterRequirement)[keyof typeof LoggingConfigurationFilterRequirement];
export declare const LoggingConfigurationLoggingFilterPropertiesDefaultBehavior: {
    readonly Keep: "KEEP";
    readonly Drop: "DROP";
};
/**
 * Default handling for logs that don't match any of the specified filtering conditions.
 */
export declare type LoggingConfigurationLoggingFilterPropertiesDefaultBehavior = (typeof LoggingConfigurationLoggingFilterPropertiesDefaultBehavior)[keyof typeof LoggingConfigurationLoggingFilterPropertiesDefaultBehavior];
export declare const RegexPatternSetScope: {
    readonly Cloudfront: "CLOUDFRONT";
    readonly Regional: "REGIONAL";
};
/**
 * Use CLOUDFRONT for CloudFront RegexPatternSet, use REGIONAL for Application Load Balancer and API Gateway.
 */
export declare type RegexPatternSetScope = (typeof RegexPatternSetScope)[keyof typeof RegexPatternSetScope];
export declare const RuleGroupBodyParsingFallbackBehavior: {
    readonly Match: "MATCH";
    readonly NoMatch: "NO_MATCH";
    readonly EvaluateAsString: "EVALUATE_AS_STRING";
};
/**
 * The inspection behavior to fall back to if the JSON in the request body is invalid.
 */
export declare type RuleGroupBodyParsingFallbackBehavior = (typeof RuleGroupBodyParsingFallbackBehavior)[keyof typeof RuleGroupBodyParsingFallbackBehavior];
export declare const RuleGroupForwardedIPConfigurationFallbackBehavior: {
    readonly Match: "MATCH";
    readonly NoMatch: "NO_MATCH";
};
export declare type RuleGroupForwardedIPConfigurationFallbackBehavior = (typeof RuleGroupForwardedIPConfigurationFallbackBehavior)[keyof typeof RuleGroupForwardedIPConfigurationFallbackBehavior];
export declare const RuleGroupIPSetForwardedIPConfigurationFallbackBehavior: {
    readonly Match: "MATCH";
    readonly NoMatch: "NO_MATCH";
};
export declare type RuleGroupIPSetForwardedIPConfigurationFallbackBehavior = (typeof RuleGroupIPSetForwardedIPConfigurationFallbackBehavior)[keyof typeof RuleGroupIPSetForwardedIPConfigurationFallbackBehavior];
export declare const RuleGroupIPSetForwardedIPConfigurationPosition: {
    readonly First: "FIRST";
    readonly Last: "LAST";
    readonly Any: "ANY";
};
export declare type RuleGroupIPSetForwardedIPConfigurationPosition = (typeof RuleGroupIPSetForwardedIPConfigurationPosition)[keyof typeof RuleGroupIPSetForwardedIPConfigurationPosition];
export declare const RuleGroupJsonMatchScope: {
    readonly All: "ALL";
    readonly Key: "KEY";
    readonly Value: "VALUE";
};
/**
 * The parts of the JSON to match against using the MatchPattern.
 */
export declare type RuleGroupJsonMatchScope = (typeof RuleGroupJsonMatchScope)[keyof typeof RuleGroupJsonMatchScope];
export declare const RuleGroupLabelMatchScope: {
    readonly Label: "LABEL";
    readonly Namespace: "NAMESPACE";
};
export declare type RuleGroupLabelMatchScope = (typeof RuleGroupLabelMatchScope)[keyof typeof RuleGroupLabelMatchScope];
export declare const RuleGroupPositionalConstraint: {
    readonly Exactly: "EXACTLY";
    readonly StartsWith: "STARTS_WITH";
    readonly EndsWith: "ENDS_WITH";
    readonly Contains: "CONTAINS";
    readonly ContainsWord: "CONTAINS_WORD";
};
/**
 * Position of the evaluation in the FieldToMatch of request.
 */
export declare type RuleGroupPositionalConstraint = (typeof RuleGroupPositionalConstraint)[keyof typeof RuleGroupPositionalConstraint];
export declare const RuleGroupRateBasedStatementAggregateKeyType: {
    readonly Ip: "IP";
    readonly ForwardedIp: "FORWARDED_IP";
};
export declare type RuleGroupRateBasedStatementAggregateKeyType = (typeof RuleGroupRateBasedStatementAggregateKeyType)[keyof typeof RuleGroupRateBasedStatementAggregateKeyType];
export declare const RuleGroupScope: {
    readonly Cloudfront: "CLOUDFRONT";
    readonly Regional: "REGIONAL";
};
/**
 * Use CLOUDFRONT for CloudFront RuleGroup, use REGIONAL for Application Load Balancer and API Gateway.
 */
export declare type RuleGroupScope = (typeof RuleGroupScope)[keyof typeof RuleGroupScope];
export declare const RuleGroupSizeConstraintStatementComparisonOperator: {
    readonly Eq: "EQ";
    readonly Ne: "NE";
    readonly Le: "LE";
    readonly Lt: "LT";
    readonly Ge: "GE";
    readonly Gt: "GT";
};
export declare type RuleGroupSizeConstraintStatementComparisonOperator = (typeof RuleGroupSizeConstraintStatementComparisonOperator)[keyof typeof RuleGroupSizeConstraintStatementComparisonOperator];
export declare const RuleGroupTextTransformationType: {
    readonly None: "NONE";
    readonly CompressWhiteSpace: "COMPRESS_WHITE_SPACE";
    readonly HtmlEntityDecode: "HTML_ENTITY_DECODE";
    readonly Lowercase: "LOWERCASE";
    readonly CmdLine: "CMD_LINE";
    readonly UrlDecode: "URL_DECODE";
    readonly Base64Decode: "BASE64_DECODE";
    readonly HexDecode: "HEX_DECODE";
    readonly Md5: "MD5";
    readonly ReplaceComments: "REPLACE_COMMENTS";
    readonly EscapeSeqDecode: "ESCAPE_SEQ_DECODE";
    readonly SqlHexDecode: "SQL_HEX_DECODE";
    readonly CssDecode: "CSS_DECODE";
    readonly JsDecode: "JS_DECODE";
    readonly NormalizePath: "NORMALIZE_PATH";
    readonly NormalizePathWin: "NORMALIZE_PATH_WIN";
    readonly RemoveNulls: "REMOVE_NULLS";
    readonly ReplaceNulls: "REPLACE_NULLS";
    readonly Base64DecodeExt: "BASE64_DECODE_EXT";
    readonly UrlDecodeUni: "URL_DECODE_UNI";
    readonly Utf8ToUnicode: "UTF8_TO_UNICODE";
};
/**
 * Type of text transformation.
 */
export declare type RuleGroupTextTransformationType = (typeof RuleGroupTextTransformationType)[keyof typeof RuleGroupTextTransformationType];
export declare const WebACLBodyParsingFallbackBehavior: {
    readonly Match: "MATCH";
    readonly NoMatch: "NO_MATCH";
    readonly EvaluateAsString: "EVALUATE_AS_STRING";
};
/**
 * The inspection behavior to fall back to if the JSON in the request body is invalid.
 */
export declare type WebACLBodyParsingFallbackBehavior = (typeof WebACLBodyParsingFallbackBehavior)[keyof typeof WebACLBodyParsingFallbackBehavior];
export declare const WebACLForwardedIPConfigurationFallbackBehavior: {
    readonly Match: "MATCH";
    readonly NoMatch: "NO_MATCH";
};
export declare type WebACLForwardedIPConfigurationFallbackBehavior = (typeof WebACLForwardedIPConfigurationFallbackBehavior)[keyof typeof WebACLForwardedIPConfigurationFallbackBehavior];
export declare const WebACLIPSetForwardedIPConfigurationFallbackBehavior: {
    readonly Match: "MATCH";
    readonly NoMatch: "NO_MATCH";
};
export declare type WebACLIPSetForwardedIPConfigurationFallbackBehavior = (typeof WebACLIPSetForwardedIPConfigurationFallbackBehavior)[keyof typeof WebACLIPSetForwardedIPConfigurationFallbackBehavior];
export declare const WebACLIPSetForwardedIPConfigurationPosition: {
    readonly First: "FIRST";
    readonly Last: "LAST";
    readonly Any: "ANY";
};
export declare type WebACLIPSetForwardedIPConfigurationPosition = (typeof WebACLIPSetForwardedIPConfigurationPosition)[keyof typeof WebACLIPSetForwardedIPConfigurationPosition];
export declare const WebACLJsonMatchScope: {
    readonly All: "ALL";
    readonly Key: "KEY";
    readonly Value: "VALUE";
};
/**
 * The parts of the JSON to match against using the MatchPattern.
 */
export declare type WebACLJsonMatchScope = (typeof WebACLJsonMatchScope)[keyof typeof WebACLJsonMatchScope];
export declare const WebACLLabelMatchScope: {
    readonly Label: "LABEL";
    readonly Namespace: "NAMESPACE";
};
export declare type WebACLLabelMatchScope = (typeof WebACLLabelMatchScope)[keyof typeof WebACLLabelMatchScope];
export declare const WebACLPositionalConstraint: {
    readonly Exactly: "EXACTLY";
    readonly StartsWith: "STARTS_WITH";
    readonly EndsWith: "ENDS_WITH";
    readonly Contains: "CONTAINS";
    readonly ContainsWord: "CONTAINS_WORD";
};
/**
 * Position of the evaluation in the FieldToMatch of request.
 */
export declare type WebACLPositionalConstraint = (typeof WebACLPositionalConstraint)[keyof typeof WebACLPositionalConstraint];
export declare const WebACLRateBasedStatementAggregateKeyType: {
    readonly Ip: "IP";
    readonly ForwardedIp: "FORWARDED_IP";
};
export declare type WebACLRateBasedStatementAggregateKeyType = (typeof WebACLRateBasedStatementAggregateKeyType)[keyof typeof WebACLRateBasedStatementAggregateKeyType];
export declare const WebACLScope: {
    readonly Cloudfront: "CLOUDFRONT";
    readonly Regional: "REGIONAL";
};
/**
 * Use CLOUDFRONT for CloudFront WebACL, use REGIONAL for Application Load Balancer and API Gateway.
 */
export declare type WebACLScope = (typeof WebACLScope)[keyof typeof WebACLScope];
export declare const WebACLSizeConstraintStatementComparisonOperator: {
    readonly Eq: "EQ";
    readonly Ne: "NE";
    readonly Le: "LE";
    readonly Lt: "LT";
    readonly Ge: "GE";
    readonly Gt: "GT";
};
export declare type WebACLSizeConstraintStatementComparisonOperator = (typeof WebACLSizeConstraintStatementComparisonOperator)[keyof typeof WebACLSizeConstraintStatementComparisonOperator];
export declare const WebACLTextTransformationType: {
    readonly None: "NONE";
    readonly CompressWhiteSpace: "COMPRESS_WHITE_SPACE";
    readonly HtmlEntityDecode: "HTML_ENTITY_DECODE";
    readonly Lowercase: "LOWERCASE";
    readonly CmdLine: "CMD_LINE";
    readonly UrlDecode: "URL_DECODE";
    readonly Base64Decode: "BASE64_DECODE";
    readonly HexDecode: "HEX_DECODE";
    readonly Md5: "MD5";
    readonly ReplaceComments: "REPLACE_COMMENTS";
    readonly EscapeSeqDecode: "ESCAPE_SEQ_DECODE";
    readonly SqlHexDecode: "SQL_HEX_DECODE";
    readonly CssDecode: "CSS_DECODE";
    readonly JsDecode: "JS_DECODE";
    readonly NormalizePath: "NORMALIZE_PATH";
    readonly NormalizePathWin: "NORMALIZE_PATH_WIN";
    readonly RemoveNulls: "REMOVE_NULLS";
    readonly ReplaceNulls: "REPLACE_NULLS";
    readonly Base64DecodeExt: "BASE64_DECODE_EXT";
    readonly UrlDecodeUni: "URL_DECODE_UNI";
    readonly Utf8ToUnicode: "UTF8_TO_UNICODE";
};
/**
 * Type of text transformation.
 */
export declare type WebACLTextTransformationType = (typeof WebACLTextTransformationType)[keyof typeof WebACLTextTransformationType];
